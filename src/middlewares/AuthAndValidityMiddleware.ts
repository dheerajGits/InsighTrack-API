import { verify } from "jsonwebtoken";
import { Request, Response, NextFunction } from "express";
import PrismaClient from "../utils/PrismaClient";
import dayjs from "dayjs";

const authAndValidityMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { authorization } = req.headers; // to get the auth headers
    // check if it is basic authorisation
    if (!authorization.startsWith("Basic ")) {
      return null;
    }
    const decodedCredentials = Buffer.from(
      authorization.split(" ")[1],
      "base64"
    ).toString("utf-8");
    const [apiKey, apiToken] = decodedCredentials.split(":");
    // apiKey is the encrypted companyId, and
    const key = process.env.API_KEYJWT;
    if (!apiKey || !apiToken) {
      res.status(403).send({ message: "apiToken or apiKey not specified" });
      return;
    }

    const organisationId = (await verify(apiKey, key))?.id;
    const organisationDetails = await PrismaClient.organisation.findUnique({
      where: {
        id: organisationId,
      },
    }); // if the id is available then we can more forward
    if (!organisationDetails) {
      res.status(403).send({ message: "wrong api key" });
      return;
    }
    // Now we need to check the validity of the apiToken which is generated by it
    const tokenDetails = await PrismaClient.tokens.findUnique({
      where: {
        id: apiToken,
      },
    });
    // we will check if token belongs to the same company and it has not expired
    if (
      !dayjs(tokenDetails.expiryDate).isAfter(dayjs()) &&
      tokenDetails.organisationId != organisationId
    ) {
      res.status(403).send({
        message: "Either token expired or wrong token username combination",
      });
      return;
    }
    next();
  } catch (e) {
    res.status(403).send({
      message: "Authentication Error",
    });
  }
};
export default authAndValidityMiddleware;
